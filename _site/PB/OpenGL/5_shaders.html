
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Shaders</title>
    
    <meta name="author" content="">

    <!-- Enable responsive viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Bootstrap styles -->
    <link href="/assets/themes/bootstrap-3/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <!-- Optional theme -->
    <link href="/assets/themes/bootstrap-3/bootstrap/css/bootstrap-theme.min.css" rel="stylesheet">
    <!-- Sticky Footer -->
    <link href="/assets/themes/bootstrap-3/bootstrap/css/bs-sticky-footer.css" rel="stylesheet">
    
    <!-- Custom styles -->
    <link href="/assets/themes/bootstrap-3/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!-- Update these with your own images
      <link rel="shortcut icon" href="images/favicon.ico">
      <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
      <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
      <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
    -->

    <!-- atom & rss feed -->
    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

  </head>

  <body>
    <div id="wrap">
      <nav class="navbar navbar-default" role="navigation">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#jb-navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/"></a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="jb-navbar-collapse">
          <ul class="nav navbar-nav">
            
            
            


  
    
      
      	
      	<li><a href="/about.html">About Me</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/CV.html">CV</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/Research.html">Research</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/Software.html">Software</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/PBrain.html">Peripheral Brain</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  



          </ul>
          <form class="navbar-form navbar-right" role="search">
            <div class="form-group">
              <input type="text" class="form-control" placeholder="Search">
            </div>
            <button type="submit" class="btn btn-default">Submit</button>
          </form>
        </div><!-- /.navbar-collapse -->
      </nav>

      <div class="container">
        
<div class="page-header">
  <h1>Shaders </h1>
</div>

<div class="row">
  <div class="col-xs-12">
    <p>After we have described the positions of the vertices, we need to describe how those vertices create shapes, and how those shapes map to pixels. This functionality is achieved with shaders, and shaders are coded in the OpenGL Shading Language (GLSL). GLSL code can be quickly uploaded and compiled on the graphics card, so it can actually interface well with a language like Julia to quickly create shaders as needed.</p>

<p>Even Julia users who will ultimately dive into the nitty gritty of OpenGL wrappers hopefully won’t have to write shaders of their own. Shaders can get incredibly complex and continue to evolve as programmers figure out how to render more and more realistic visual scenes. Therefore, julia user should be most familiar with what kinds of inputs and outputs enter and leave shaders.</p>

<h3 id="vertex-shader">Vertex Shader</h3>

<p>Vertex shaders describe how points in space are assembled together. Ultimately these result in 4D points. If you are working with something that is actually 2D, the user need only supply 2 points. A shader definition in Julia can be written in GLSL code wrapped by a julia macro:</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="kd">const</span> <span class="n">vsh</span> <span class="o">=</span> <span class="n">vert</span><span class="s">"""

in vec2 position;
void main(){
    	gl_Position = vec4(position, 0, 1.0);
}
"""</span></code></pre></figure>

<p>Variables that are passed from the CPU to the GPU are identified as “in” variables. Any variables that would need to be passed directly onto the texture shader would be identified as “out.” Finally, there can be input variables called “uniform” where one value or group of values is passed from the CPU to GPU, but all vertexes in the same buffer will use that same value. In this way, the same value does not have to be passed over and over again. For instance if you want to move a complicated 3D mesh with many many vertices in the x direction by 1.0, it would be much more efficient to pass 1.0 once, rather than over and over again for each vertex.</p>

<h3 id="texture-shader">Texture Shader</h3>

<p>A texture shader takes the vertex shaders and creates pixels on the screen. OpenGL can figure out where the pixels need to go; the user needs to specify the color and opacity.</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="kd">const</span> <span class="n">fsh</span> <span class="o">=</span> <span class="n">frag</span><span class="s">"""

out vec4 outColor;
void main() {
    	outColor = vec4(1.0, 1.0, 1.0, 1.0);
}
"""</span></code></pre></figure>

<h3 id="bringing-shaders-together">Bringing shaders together</h3>

<p>Now that we have written our shaders, we need to have them be appropriately compiled and linked under the hood so OpenGL knows how to use them. The LazyShader function provides this ability:</p>

<figure class="highlight"><pre><code class="language-julia" data-lang="julia"><span class="n">l</span><span class="o">=</span><span class="n">LazyShader</span><span class="x">(</span><span class="n">vsh</span><span class="x">,</span><span class="n">fsh</span><span class="x">)</span></code></pre></figure>

<p>Now we have almost everything we need to make shapes appear on the computer screen. Next, we need to bring it all together in a nice Julia type, and make it display on the screen.</p>

<p>Next:
<a href="6_simple_shape.html">Simple Shape</a></p>

<p>Previous:
<a href="4_opengl_buffer.html">GPU Buffer</a></p>


  </div>
</div>


      </div>

    </div>

    <div id="footer">
      <div class="container">
        <p>&copy; 2016 
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>
        </p>
      </div>
    </div>

    




  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-123-12']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>





  </body>
</html>

